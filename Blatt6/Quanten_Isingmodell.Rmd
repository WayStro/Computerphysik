---
title: "Quanten Isingmodell"
author: "Silas Müller, Wayne Ströbel"
date: "10 7 2021"
output: pdf_document
---

```{r setup, include=FALSE}
library(arrayhelpers)
library(knitr)
library(data.table)
knitr::opts_chunk$set(echo = TRUE)
```

# Das Quanten-Isingmodell

Beim Quanten Isingmodell mit transversalem Feld sind N quantenmechanische Spins auf einem eindimensionalen Gitter angeordnet. Der Hamilton-Operator, der die Dynamik dieser Spins mit offenen Randbedingungen beschreibt, hat
folgende Form:
$$H=\sum_{i=0}^{N-2}\sigma_i^x \otimes \sigma_{i+1}^x+g\sum_{i=0}^{N-1}\sigma_i^z$$
Der erste Term des Hamiltonoperators ist der Wechselwirkungsterm
zwischen den Spins an den Gitterpunkten $i$ und $i+1$. Der zweite Term beschreibt ein externes magnetisches Feld mit Kopplung $g$.
Mit den bekannten Paulimatrizen $\sigma_i^x$ und $\sigma_i^z$ jeweils am Gitterpunkt (Zustand) $i$. \newline
Als Basis der Zustände an einem Gitterpunkt i wählen wir die Eigenbasis
von $\sigma^z$, also:
$$\ket{\Phi}=\alpha_0 \ket{0} + \alpha_1 \ket {1}$$
Dabei gilt auf Grund der Normierung für die Amplituden $\alpha_i$: $\sum_i\alpha_i^2=1$.
Der Zustand für alle Spins ergibt sich dann aus dem Tesnorprodukt aller Einspinzustände an den Gitterpunkten 0 bis N-1 ,also $\ket{00\dots 00}$,$\ket{00\dots 01}$,$\ket{00\dots 10}$,$\dots$ .
Es gibt $2^N$ solcher Basiszustände und dementsprechend $2^N$ Amplituden. \newline
Das Modell hat bei $g=1$ einen Quanten-Phasenübergang, der in der transversalen Magnetisierung
$$M=\frac{1}{N}\braket{\psi|\sum_{i=0}^{N-1}\sigma_i^z|\psi}$$
sichtbar wird, wobei $\ket{\psi}$ ein Zustand des N-Spin-Systems ist.

# Aufgabenstellung

Wir sollen die Grundzustandenergie, Grundzustandwellenfunktion und Magnetisierung M im Grunszustand für N=2, N=4, N=6, N=8 und N=10 für $g\in[0,2]$ bestimmen. \newline
Außerdem soll die Energie und die Magnetisierung als Funktion von g dargestellt werden.\newline
Abschließend vergleichen wir die Kurven für verschiedene N, interpretieren die Ergebnisse und diskutieren das Konvergenzverhalten des Algorithmus für N = 4 und g = 0.5.

# Vorüberlegungen

Es sei hier zuerst explizit auf die Vorlesung vom 7.7.2021 verwiesen, in welcher die Theorie und genauere Erläuterung zu finden ist. Hier soll noch einmal das wichtigste für den Algorithmus hervorgehoben und unsere Vorgehensweise erläutert werden. \newline
ÜBERLEGUNGEN.

# Grundzustandenergie, Grundzustandswellenfunktion

BLA

## Code 

```{r}
#Zustandsfunktion, WICHTIG: <00001| enspricht hier 10000
zufu <- function(N){
  l <- rep(list(0:1), N)
  expand.grid(l)
}

#Sigma_z_i; Spalten = N, Zeilen = N^2
sigm_zi <- function(mat, N, i){
  mat[i] <- -mat[i]
  mat
}

#Sigma_x_i; 
sigma_xi <- function(mat, N, i){
  for (a in c(1:(2^N-1))){
    for (b in c((a+1):2^N)){
      tmp <- mat[a,] - mat[b,]
      if (sqrt(sum(tmp^2)) == 1 && unlist(unname(abs(tmp[i]))) == 1){
        tmp2 <- mat[b,]
        mat[b,] <- mat[a,]
        mat[a,] <- tmp2
      }
    }
  }
  mat
}






N <- 4
mat <- zufu(N)

mat
```



```{r}

Hamilton <- function(g, SIGMA_X_SUM, SIGMA_Z_SUM){
  
  ham <- SIGMA_X_SUM + g*SIGMA_Z_SUM
  
}

TENSORPRODUKT <- function(x1, ...){
  r <- x1
  for (vi in list(...)){
    r <- r %o% vi
  }
  r
}

EINHEITSMATRIX = matrix(c(1,0,0,1), nrow=2, ncol=2)
SIGMAZ = matrix(c(1,0,0,-1), nrow=2, ncol=2)
SIGMAX = matrix(c(0,1,1,0), nrow=2, ncol=2)

SIGMA_Z_SUM <- function(n, EINHEITSMATRIX, SIGMAZ){
  
  value <- 0
  l <- 0
  
  for (i in c(1:n)) {
    
    for (k in 1:n) {
      l[k] <- list(EINHEITSMATRIX)
    }
  
    l[i] <- list(SIGMAZ)
    
    for (a in c(1:(n-1))) {
      l[1] <- list(TENSORPRODUKT(l[[1]], l[[a+1]]))
    }
    
    value <- value + l[[1]]
  }
  value
  
}

SIGMA_X_SUM <- function(n, EINHEITSMATRIX, SIGMAX){
  
  value <- 0
  
  for (i in c(1:(n-1))) {
    
    l <- 0
    
    for (k in 1:n) {
      l[k] <- list(EINHEITSMATRIX)
    }
  
    l[i] <- list(SIGMAX)
    l[i+1] <- list(SIGMAX)
    
    for (a in c(1:(n-1))) {
      l[1] <- list(TENSORPRODUKT(l[[1]], l[[a+1]]))
    }
    
    value <- value + l[[1]]
  }
  value
  
}


Eigenvalue <- function( x, A, steps){
  
  lambda <- 0
  
  for (k in (1:steps)) {
    w <- A %*% x
    x <- w/sqrt(sum(w*Conj(w)))
    u <- A %*% x
    lambda <- sqrt(sum(u*Conj(u)/sum(v*Conj(v))))
  }
}






g <- 1
n <- 4

ham <- Hamilton(g, SIGMA_X_SUM(n, EINHEITSMATRIX, SIGMAX), SIGMA_Z_SUM(n, EINHEITSMATRIX, SIGMAZ))

ham







```

## Ergebnisse



# Magnetisierung als Funktion von g



## Code/Plots



## Vergleich für verschiedene N und Interpretation



# Diskussion des Konvergenzverhaltens


# Fazit



# Literatur

\textit{Zustandsfunktion, 
\url{https://stackoverflow.com/questions/3993546/how-to-generate-a-matrix-of-combinations}, Stand: 10.07.2021}

