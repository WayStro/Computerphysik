---
title: "Blatt 5: Spektrum einer Klaviersaite"
author: "Wayne Ströbel, Silas Müller"
date: "7/3/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Spektrum einer Klaviersaite

Eine Klaviersaite der Länge $l=0.4m$ mit linearer Massenbelegung $\rho=0.0006 kg/m$ ist rechts und links fixiert und mit der Kraft $F=743.4N$ gespannt. Wir betrachten transversale Wellen in der Auslenkung $\psi(x,t)$ beschrieben durch die Wellengleichung:
$$\frac{\partial^2\psi(x,t)}{\partial t^2}=c^2\frac{\partial^2\psi(x,t)}{\partial x^2}-\frac{\gamma}{l} \Biggl| \frac{\partial \psi(x,t)}{\partial t} \Biggl| \frac{\partial \psi(x,t)}{\partial t}$$
mit $\gamma=1/3$. \newline
Die Saite wird durch einen Hammer $\delta$-artig angeschlagen.\newline
Es soll zunächst die Schwingung der Saite mit entsprechenden Anfangsbedingungen simuliert und anschließend das Spektrum der Saite vom Grundton bis zum fünften Oberton aus der simulierten Zeitentwicklung mittels Fourier Transformation bestimmt werden. Außerdem soll für den Spezialfall $\gamma=0$ überprüft werden, ob unsere Diskretisierungslängen eine stabile Simulation ermöglichen. Abschließend sollen die Amplituden der verschiedenen Frequenzen zeitlich aufgelöst und erläutert werden.

# Simulation der Schwingung

## Numerische Vorüberlegung

Um die oben genannte Schwingung zu simulieren betrachten wir zunächst obige Differentialgleichung und transformieren in dimensionslose Koordinaten:
$$\tau=\frac{t}{T},\enspace a=\frac{x}{l}, \enspace T=\frac{l}{c} \enspace, \phi=\psi l$$
Daraus ergibt sich folgende dimensionslose DGL:
$$\frac{\partial^2\phi(a,\tau)}{\partial \tau^2}=\frac{\partial^2\phi(a,\tau)}{\partial a^2}-\gamma \Biggl| \frac{\partial \phi(a,\tau)}{\partial \tau} \Biggl| \frac{\partial \phi(a,\tau)}{\partial \tau}$$
Darauf wenden wir nun unsere bekannten numerische Approximationen an, im folgenden gelten die Abkürzungen: $U_{tt}=\frac{\partial^2\phi(a,\tau)}{\partial \tau^2}$, analog für $U_{xx}$ bzw. $U_{x}$ und $U_{t}$. Außerdem sei $U_{ij}=\phi(\tau_i,a_j)$.
$$U_{tt}=\frac{U_{i+1,j}-2U_{i,j}+U_{i-1,j}}{h_t^2}$$
$$U_{xx}=\frac{U_{i,j+1}-2U_{i,j}+U_{i,j-1}}{h_x^2}$$
$$U_{t}=\frac{U_{i,j}-U_{i-1,j}}{h_t}$$
Wobei $h_t$ und $h_x$ den jeweiligen Diskretisierungsgrößen entsprechen.\newline
Nun setzt man obige Definitionen in die dimensionlose DGL ein und löst nach $U_{i+1,j}$ auf:
$$U_{i+1,j}=\frac{h_t^2}{h_x^2}(U_{i,j+1}-2U_{i,j}+U_{i,j-1})-\gamma |U_{i,j}-U_{i-1,j}| (U_{i,j}-U_{i-1,j})+2U_{i,j}-U_{i-1,j}$$
Mit Hilfe dieser Formel wollen wir nun für verschiedene Zeiten jeweils alle Ortskoordinaten ermitteln und das Problem so simulieren. Dabei ist zu erwähnen, dass die Simulation von dem Hammerschlag ausgeht und auf Grunde der Anfangswerte (für alle x außer am Hammerschlag):
$$\frac{\partial\psi(x,t=0)}{\partial t}=0, \enspace \psi(x,0)=0$$ 
gilt, dass wir zum Start $U_{0,0.26}=U_{0-1,0.26}=\frac{0.01m}{0.4m}$ wählen können.

## Code
```{r}
library(latex2exp)
#Anfangswerte und Zeit/Step Einstellungen
strike = 0.01
l = 0.4
steps = 1000
times = 20000
dx = 1/steps
dt = 1/10000
gamma = 1./3.

dxdt = (dt^2)/(dx^2)

time <- c(2:(times-1))
step <- c(2:(steps-1))


#Auffüllen der Matrix mit Nullen
u <- matrix(0.0, nrow = times,ncol = steps)

#Startwerte einfügen
u[2, 0.26*steps] <- strike/l
u[1, 0.26*steps] <- strike/l


#Simulation
for (i in time){
  for (j in step){
    
    u[i+1,j] = 1 / (1 + gamma * abs(u[i, j] - u[i-1, j])) * (dxdt  * (u[i, j+1] - 2*u[i, j] + u[i, j-1]) + 2*u[i, j] - u[i-1, j] + gamma * abs(u[i, j] - u[i-1, j]) * (u[i,j]))
    
    
  }
}


#Plot der örtlichen Werte zu verschiedenen Zeitpunkten
plot(1:steps, u[2,], "l", col=rainbow(6)[1], main="Örtliche Auftragung für verschiedene Zeiten", xlab=TeX(r'($\frac{l}{x} * 1000$)'), ylab=TeX(r'($\phi$)'))
lines(1:steps, u[100,], col=rainbow(6)[2])
lines(1:steps, u[500,], col=rainbow(6)[3])
lines(1:steps, u[1000,], col=rainbow(6)[4])
lines(1:steps, u[10000,], col=rainbow(6)[5])
lines(1:steps, u[20000,], col=rainbow(6)[6])





plot((1:times)*dt, u[,260], "l", main="Zeitliche Auftragung für einen Ort", xlab=TeX(r'($\tau$)'), ylab=TeX(r'($\phi$)'))
```

# Spektrum der Saite




## Code

```{r}


#Koeffizient für Fouriertrafo
koeff <- function(n,k){
  
  w = complex(real = cos(-2*pi*k/n), imaginary = sin(-2*pi*k/n))  
  
  return(w)
}




#Fast Fourier Trafo
FFT <- function(func, r){
  
  n = 2^r
  m = n/2
  Kap = 1
  
  for (i in c(1:r)){
    for (k in c(1: Kap)){
      for (j in c(1: m)){
        
        a = 2*k*m +j
        b = a + m
        func[a] = func[a] + func[b]
        func[b] = koeff(n,Kap*j) * (func[a] - 2*func[b])
        
      }
    }
    
    m = m/2
    Kap = 2*Kap
  }
  
  return(func/sqrt(n))
}



#Sortierung der Werte der Fouriertrafo
sort <- function(n, toSort){
  
  vec <- c(1: n)
  l = 0
  Sorted <- c(1: n)
  for (i in c(1: n-1)){
    
    vec[i] = l
    m = n/2
    while (m <= l){
      l = l-m
      m = m/2
    }
    l = l + m
  }
  
  vec[n] = n-1
  
  for (i in c(1: n)){
    
    Sorted[i] = toSort[vec[i]]
  }
  return(Sorted)
}

#Gegebene Werte

Force = 743.4
l = 0.4
roh = 0.006

#Ausbreitungsgeschwindigkeit
c = 1/2 * sqrt(Force/roh)


r = 14
n = 2^r

#Eintragen Fourier Trafo der Zeitlichen Entwicklung an verschiedenen Orten
tmp <- sort(n, FFT(u[,245], r))
a_list <- list(tmp)


for (i in c(1:15)){
  temp <- sort(n, FFT(u[,245+i], r))
  a_list <- c(a_list, list(temp))
}


#Plotten
plot(seq(1, 20000, length.out=(2^r))* dt * c/l, Re(unlist(a_list[1])), "l", col="red", ylim=c(0,0.01), main="Zeitliche FFT für festen Ort", ylab="", xlab=TeX('($Hz$)'))


for (i in c(1:15)){
  
  lines(seq(1, 20000, length.out=(2^r))* dt* c/l, Re(unlist(a_list[1+i])), col=rainbow(length(c(1:15)))[i])
  
}


```

# Ungedämpft



## Simulation
```{r, echo=FALSE}
#Anfangswerte und Zeit/Step Einstellungen
gamma2 = 0.


#Auffüllen der Matrix mit Nullen
u2 <- matrix(0.0, nrow = times,ncol = steps)

#Startwerte einfügen
u2[2, 0.26*steps] <- strike/l
u2[1, 0.26*steps] <- strike/l


#Simulation
for (i in time){
  for (j in step){
    
    u2[i+1,j] = 1 / (1 + gamma2 * abs(u2[i, j] - u2[i-1, j])) * (dxdt  * (u2[i, j+1] - 2*u2[i, j] + u2[i, j-1]) + 2*u2[i, j] - u2[i-1, j] + gamma2 * abs(u2[i, j] - u2[i-1, j]) * (u2[i,j]))
    
    
  }
}


#Plot der örtlichen Werte zu verschiedenen Zeitpunkten
plot(1:steps, u2[2,], "l", col=rainbow(6)[1], main="Örtliche Auftragung für verschiedene Zeiten", xlab=TeX(r'($\frac{l}{x} * 1000$)'), ylab=TeX(r'($\phi$)'))
lines(1:steps, u2[100,], col=rainbow(6)[2])
lines(1:steps, u2[500,], col=rainbow(6)[3])
lines(1:steps, u2[1000,], col=rainbow(6)[4])
lines(1:steps, u2[10000,], col=rainbow(6)[5])
lines(1:steps, u2[20000,], col=rainbow(6)[6])





plot((1:times)*dt, u2[,260], "l", main="Zeitliche Auftragung für einen Ort", xlab=TeX(r'($\tau$)'), ylab=TeX(r'($\phi$)'))
```


## Spektrum

```{r, echo=FALSE}

tmp <- sort(n, FFT(u2[,245], r))
a_list2 <- list(tmp)


for (i in c(1:15)){
  temp <- sort(n, FFT(u2[,245+i], r))
  a_list2 <- c(a_list, list(temp))
}


plot(seq(1, 20000, length.out=(2^r))* dt * c/l, Re(unlist(a_list2[1])), "l", col="red", ylim=c(0,0.01), main="Zeitliche FFT für festen Ort", ylab="", xlab=TeX('($Hz$)'))


for (i in c(1:15)){
  
  lines(seq(1, 20000, length.out=(2^r))* dt* c/l, Re(unlist(a_list2[1+i])), col=rainbow(length(c(1:15)))[i])
  
}


```


